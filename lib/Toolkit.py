#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# Toolkit for functions between scripts
#
# Software is free software released under the "GNU Affero General Public License v3.0"
#
# Copyright (c) 2014-2019  Pieter-Jan Moreels - pieter-jan@pidgey.net

# Imports
from dateutil import tz

import urllib
import dateutil.parser
import re

class hashableDict(dict):
    def __hash__(self):
        return hash(tuple(sorted(self.items())))

# Note of warning: CPEs like cpe:/o:microsoft:windows_8:-:-:x64 are given to us by Mitre
#  x64 will be parsed as Edition in this case, not Architecture
def toStringFormattedCPE(cpe,autofill=False):
    cpe=cpe.strip()
    if not cpe.startswith('cpe:2.3:'):
        if not cpe.startswith('cpe:/'): return False
        cpe=cpe.replace('cpe:/','cpe:2.3:')
        cpe=cpe.replace('::',':-:')
        cpe=cpe.replace('~-','~')
        cpe=cpe.replace('~',':-:')
        cpe=cpe.replace('::',':')
        cpe=cpe.strip(':-')
        cpe=unquote(cpe)
    if autofill:
        e=cpe.split(':')
        for _ in range(13-len(e)):
            cpe+=':-'
    return cpe

# Note of warning: Old CPE's can come in different formats, and are not uniform. Possibilities are:
# cpe:/a:7-zip:7-zip:4.65::~~~~x64~
# cpe:/a:7-zip:7-zip:4.65:-:~~~~x64~
# cpe:/a:7-zip:7-zip:4.65:-:~-~-~-~x64~
def toOldCPE(cpe):
    cpe=cpe.strip()
    if not cpe.startswith('cpe:/'):
        if not cpe.startswith('cpe:2.3:'): return False
        cpe=cpe.replace('cpe:2.3:','')
        parts = cpe.split(':')
        next = []
        first= "cpe:/"+":".join(parts[:5])
        if last := parts[5:]:
            for x in last:
                next.append('~') if x == "-" else next.append(x)
            if "~" in next:
                pad(next,6,"~")
        cpe = f'{first}:{"".join(next)}'
        cpe=cpe.replace(':-:','::')
        cpe=cpe.strip(":")
    return cpe

def cpeTitle(cpe):
    title = toStringFormattedCPE(cpe)[10:]
    title = title.replace(':-:', ' ',10)
    title = title.replace(':', ' ',10)
    title = title.replace('_', ' ',10)
    title = urllib.parse.unquote_plus(title)
    title = title.title()
    return title

def impactScore(cve):
    score={'NONE':0,'PARTIAL':0.275,'COMPLETE':0.660}
    try:
        C = cve.impact.confidentiality.upper()
        I = cve.impact.integrity.upper()
        A = cve.impact.availability.upper()
        res = 10.41*(1-(1-score[C])*(1-score[I])*(1-score[A]))
        return min(res, 10.0)
    except:
        return '-'

def exploitabilityScore(cve):
    cScore={'LOW':0.71,'MEDIUM':0.61,'HIGH':0.35}
    vScore={'NETWORK':1.0,'ADJACENT_NETWORK':0.646,'LOCAL':0.395}
    aScore={'NONE':0.704,'SINGLE_INSTANCE':0.56,'MULTIPLE_INSTANCES':0.45}
    try:
        C = cve.access.complexity.upper()
        V = cve.access.vector.upper()
        A = cve.access.authentication.upper()
        return 20* cScore[C]*vScore[V]*aScore[A]
    except:
        return '-'

def pad(seq, target_length, padding=None):
    length = len(seq)
    if length > target_length:
        return seq
    seq.extend([padding] * (target_length - length))
    return seq

def isURL(string):
    urlTypes= [re.escape(x) for x in ['http://','https://', 'www.']]
    return re.match("^(" + "|".join(urlTypes) + ")", string)

def mergeSearchResults(database, plugins):
    if 'errors' in database:
        results = {'data':[], 'errors':database['errors']}
    else:
        results = {'data': []}

    data = []
    data.extend(database['data'])
    data.extend(plugins['data'])
    for cve in data:
        if all(cve['id'] != entry['id'] for entry in results['data']):
            results['data'].append(cve)
    return results

def compile(regexes):
    if type(regexes) not in [list, tuple]: regexes = [regexes]
    return [re.compile(rule) for rule in regexes]

def assertType(typ, **variables):
    for var in variables:
        # Turning None into NoneType
        if not isinstance(typ, tuple): typ = (typ,)
        types = tuple(x or type(None) for x in typ)
        # checking
        if not isinstance(variables[var], types):
            t = "or ".join([x.__name__ for x in types])
            raise TypeError(
                f"{var} is supposed to be of type {t}, not {type(variables[var]).__name__}"
            )

def assertTypeForAllIn(typ, var, values=True, keys=False):
    if "__iter__" not in dir(var) or isinstance(typ, str):
        raise TypeError("not iterable")
    if values:
        values = var
        if isinstance(var, dict): values = var.values()
        if not all(isinstance(x, typ) for x in values):
            raise TypeError(
                f"not all the items in the {type(var).__name__} are of type {typ.__name__}"
            )

    if (
        keys
        and isinstance(var, dict)
        and not all(isinstance(x, typ) for x in var.keys())
    ):
        raise TypeError(
            f"not all the keys in the {type(var).__name__} are of type {typ.__name__}"
        )
